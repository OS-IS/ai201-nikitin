# 4.7.5.2 Тестування для MySQL
## Підсумок
SQL Injection уразливості виникають, коли вхідні дані використовуються при побудові SQL-запиту без належного обмеження або санітарної обробки. Використання динамічного SQL (побудова SQL-запитів шляхом конкатенації рядків) відкриває шлях до цих уразливостей. SQL-ін'єкція дозволяє зловмиснику отримати доступ до SQL-серверів. Вона дозволяє виконувати SQL-код під привілеями користувача, що використовується для підключення до бази даних.

Сервер MySQL має декілька особливостей, тому деякі експлойти повинні бути спеціально налаштовані для цієї програми. Про це і піде мова в цьому розділі.

## Як тестувати
Коли в додатку, що використовує базу даних MySQL, виявлено SQL ін'єкцію, існує ряд атак, які можуть бути виконані в залежності від версії MySQL та привілеїв користувача в СУБД.

MySQL має щонайменше чотири версії, які використовуються у всьому світі: 3.23.x,4.0.x, 4.1.xта 5.0.x. Кожна версія має набір можливостей, пропорційний номеру версії.
 - Починаючи з версії 4.0: UNION
 - Починаючи з версії 4.1: Підзапити
 - Починаючи з версії 5.0: Збережені процедури, Збережені функції та подання з назвою INFORMATION_SCHEMA
 - Починаючи з версії 5.0.2: Тригери
   
Слід зазначити, що для версій MySQL до 4.0.x можна було використовувати лише логічні атаки або атаки на основі часових параметрів, оскільки функціонал підзапитів або оператори UNION не були реалізовані.

Надалі будемо вважати, що існує класична SQL ін'єкція, яка може бути спровокована запитом, подібним до того, що описаний в розділі Тестування на SQL ін'єкцію.

`http://www.example.com/page.php?id=2`

### Проблема одинарних лапок
Перед тим, як скористатися можливостями MySQL, необхідно звернути увагу на те, як рядки можуть бути представлені в операторі, оскільки часто веб-додатки екранують одинарні лапки.

Лапки в MySQL екрануються наступним чином:

`'Рядок з \'лапками\''`

Тобто MySQL інтерпретує екрановані апострофи \'як символи, а не як метасимволи.

Тому, якщо для коректної роботи додатку потрібно використовувати константні рядки, слід розрізняти два випадки:
1. Веб-додаток екранує одинарні лапки '=> \'
2. Веб-додаток не екранує одинарні лапки '=> '

В MySQL існує стандартний спосіб обійти необхідність використання одинарних лапок, коли константний рядок оголошується без необхідності використання одинарних лапок.

Припустимо, ми хочемо дізнатися значення поля з ім'ям passwordу записі, з умовою, подібною до наступної:
1. password типу 'A%'
2. ASCII-значення у вигляді конкатенованого шістнадцяткового числа: password LIKE 0x4125
3. Функція char(): password LIKE CHAR(65,37)

### Множинні змішані запити
Коннектори бібліотеки MySQL не підтримують декілька запитів, розділених символом ;, тому немає можливості ввести декілька неоднорідних SQL-команд в одну SQL-ін'єкцію, як в Microsoft SQL Server.
Наприклад, наступна ін'єкція призведе до помилки:

`1 ; update tablename set code='javascript code' where 1 --`

### Збір інформації
#### Відбитки пальців MySQL
Звичайно, перше, що потрібно знати, це те, чи є СУБД MySQL в якості внутрішньої бази даних. Сервер MySQL має функцію, яка дозволяє іншим СУБД ігнорувати речення на діалекті MySQL. Коли блок коментарів '/**/ 'містить знак оклику '/*! sql here*/',він інтерпретується MySQL, а іншими СУБД розглядається як звичайний блок коментарів, як пояснюється в посібнику з MySQL.

Приклад:

`1 /*! і 1=0 */`

*Якщо MySQL присутня, буде інтерпретовано речення всередині блоку коментарів.*

#### Версія
Отримати цю інформацію можна трьома способами:
1. З допомогою глобальної змінної @@version
2. З допомогою функції VERSION()
3. За допомогою дактилоскопії коментарів з номером версії /*!40110 та 1=0*/.

що означає

`if(version >= 4.1.10)`  
   `додайте до запиту 'and 1=0'.`
   
Вони еквівалентні, оскільки результат однаковий.

В ін'єкції діапазону:

`1 AND 1=0 UNION SELECT @@version /*`

Інференційна ін'єкція:

`1 AND @@version like '4.0%'`  

Відповідь буде містити щось на кшталт:

`5.0.22-log`

#### Користувач для входу
Існує два типи користувачів, на яких покладається MySQL Server.
1. USER(): користувач, підключений до сервера MySQL.
2. CURRENT_USER(): внутрішній користувач, який виконує запит.

Між 1 і 2 є деякі відмінності. Основна полягає в тому, що анонімний користувач може підключатися (якщо це дозволено) з будь-яким ім'ям, а внутрішній користувач MySQL - це порожнє ім'я (''). Інша відмінність полягає в тому, що збережена процедура або збережена функція виконуються від імені користувача-творця, якщо він не оголошений деінде. Це можна дізнатися за допомогою функції CURRENT_USER.

В ін'єкції діапазону:

`1 І 1=0 ОБ'ЄДНАННЯ SELECT USER()`

Інференційна ін'єкція:

`1 І USER() як 'root%'`

Відповідь буде містити щось на кшталт:

`user@hostname`

#### Ім'я бази даних у використанні
Існує нативна функція DATABASE()

В ін'єкції діапазону:

`1 ТА 1=0 ОБ'ЄДНАННЯ SELECT DATABASE()`

Інференційна ін'єкція:

`1 І DATABASE() як 'db%'`

Очікуваний результат, Рядок на зразок цього:

`dbname`

### INFORMATION_SCHEMA
У MySQL 5.0 було створено подання INFORMATION_SCHEMA. Воно дозволяє нам отримати всю інформацію про бази даних, таблиці та стовпці, а також процедури та функції.

| Tables_in_INFORMATION_SCHEMA | Опис |
|-------------|-------------|
| SCHEMATA  | Всі бази даних, які є у користувача (як мінімум) SELECT_priv  |
| SCHEMA_PRIVILEGES  | Привілеї, які користувач має для кожної БД  |
| TABLES  | Всі таблиці, в яких користувач має (як мінімум) SELECT_priv |
| TABLE_PRIVILEGES  | Привілеї, які користувач має для кожної таблиці  |
| COLUMNS  | Всі стовпці, які є у користувача (як мінімум) SELECT_priv  |
| COLUMN_PRIVILEGES  | Привілеї, які користувач має для кожного стовпця  |
| VIEWS  | Всі стовпці, які є у користувача (як мінімум) SELECT_priv  |
| ROUTINES  | Процедури та функції (потребує EXECUTE_priv)  |
| TRIGGERS  | Тригери (потребує INSERT_priv)  |
| USER_PRIVILEGES  | Привілеї, які має підключений користувач  |


Вся ця інформація може бути витягнута за допомогою відомих методів, описаних в розділі SQL Injection.

### Вектори атаки
#### Запис у файл
Якщо підключений користувач має привілеї FILEі одинарні лапки не екрануються, можна використати речення into outfileдля експорту результатів запиту у файл.

`Select * from table into outfile '/tmp/file'`

Зауважте: не існує способу обійти одинарні лапки, що оточують ім'я файлу. Тому, якщо є певна санітарна обробка одинарних лапок, наприклад, escape \', то не буде можливості використати речення into outfile.

Цей тип атаки може бути використаний як позасмугова техніка для отримання інформації про результати запиту або для запису файлу, який може бути виконаний всередині каталогу веб-сервера.

Приклад:

`1 limit 1 у вихідний файл '/var/www/root/test.jsp' ПОЛЯ, ОБМЕЖЕНІ '//' ЛІНІЙКИ, ЩО ЗАКІНЧУЮТЬСЯ '\n<%jsp код тут%>';`

Результати зберігаються у файлі з привілеями rw-rw-rw, що належать користувачу та групі MySQL.

Де /var/www/root/test.jspбуде містити:

`//значення полів// <%jsp-код тут%>`

#### Читання з файлу
load_file - це вбудована функція, яка може читати файл, якщо це дозволено правами файлової системи. Якщо підключений користувач має привілеї FILE, вона може бути використана для отримання вмісту файлів. Санацію екранування від використання одинарних лапок можна обійти, використовуючи раніше описані методи.

`load_file('ім'я файлу')`

*Весь файл буде доступним для експорту стандартними методами.*

### Стандартна атака SQL-ін'єкція
При стандартній SQL-ін'єкції результати можуть відображатися безпосередньо на сторінці як звичайний вивід або як помилка MySQL. Використовуючи вже згадані атаки SQL Injection і вже описані можливості MySQL, пряме введення SQL можна легко виконати на рівні глибини, що залежить, в першу чергу, від версії MySQL, з якою працює пентестер.

Хороша атака полягає в тому, щоб дізнатися результати, змусивши функцію/процедуру або сам сервер згенерувати помилку. Список помилок, які видає MySQL і, зокрема, вбудовані функції, можна знайти в MySQL Manual.

### Позамережеве введення SQL-коду
Позамежову ін'єкцію можна виконати за допомогою речення in outfile.

### Сліпе введення SQL
Для сліпої ін'єкції SQL існує набір корисних функцій, що надаються сервером MySQL.
 - Довжина рядка:
   - LENGTH(str)
 - Витягнути підрядок із заданого рядка:
   - SUBSTRING(string, offset, #chars_returned)
 - Сліпа ін'єкція за часом:
   - BENCHMARK та SLEEP BENCHMARK(#циклів,дія_що_виконується)Функція бенчмарку може бути використана для виконання атак на час, коли сліпа ін'єкція за допомогою булевих значень не дає жодних результатів. Див. SLEEP()(MySQL > 5.0.x) для альтернативи бенчмарку.


